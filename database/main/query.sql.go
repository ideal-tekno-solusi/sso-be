// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAuth = `-- name: CreateAuth :exec
insert into auths
(
    code,
    scope,
    type,
    user_id,
    insert_date
)
values
(
    $1,
    $2,
    $3,
    $4,
    now()
)
`

type CreateAuthParams struct {
	Code   pgtype.Text
	Scope  pgtype.Text
	Type   int32
	UserID pgtype.Text
}

func (q *Queries) CreateAuth(ctx context.Context, arg CreateAuthParams) error {
	_, err := q.db.Exec(ctx, createAuth,
		arg.Code,
		arg.Scope,
		arg.Type,
		arg.UserID,
	)
	return err
}

const createSession = `-- name: CreateSession :exec
insert into sessions
(
    id,
    user_id,
    insert_date
)
values
(
    $1,
    $2,
    now()
)
`

type CreateSessionParams struct {
	ID     pgtype.Text
	UserID pgtype.Text
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.Exec(ctx, createSession, arg.ID, arg.UserID)
	return err
}

const fetchClientRedirects = `-- name: FetchClientRedirects :many
select
    c.id,
    r.uri
from
    client_redirects as r
join
    clients as c
on
    r.client_id = c.id
where
    c.id = $1
`

type FetchClientRedirectsRow struct {
	ID  string
	Uri string
}

func (q *Queries) FetchClientRedirects(ctx context.Context, id string) ([]FetchClientRedirectsRow, error) {
	rows, err := q.db.Query(ctx, fetchClientRedirects, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchClientRedirectsRow
	for rows.Next() {
		var i FetchClientRedirectsRow
		if err := rows.Scan(&i.ID, &i.Uri); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuth = `-- name: GetAuth :one
select
    a.code,
    a.scope,
    t.name as type,
    a.user_id
from
    auths as a
join
    auth_types as t
on
    a.type = t.id
where
    code = $1
and
    use_date is null
`

type GetAuthRow struct {
	Code   pgtype.Text
	Scope  pgtype.Text
	Type   string
	UserID pgtype.Text
}

func (q *Queries) GetAuth(ctx context.Context, code pgtype.Text) (GetAuthRow, error) {
	row := q.db.QueryRow(ctx, getAuth, code)
	var i GetAuthRow
	err := row.Scan(
		&i.Code,
		&i.Scope,
		&i.Type,
		&i.UserID,
	)
	return i, err
}

const getClient = `-- name: GetClient :one
select
    c.id,
    c.name,
    t.name as type,
    c.secret,
    c.token_livetime
from
    clients as c
join
    client_types as t
on
    c.type = t.id
where
    c.id = $1
`

type GetClientRow struct {
	ID            string
	Name          string
	Type          string
	Secret        pgtype.Text
	TokenLivetime pgtype.Int8
}

func (q *Queries) GetClient(ctx context.Context, id string) (GetClientRow, error) {
	row := q.db.QueryRow(ctx, getClient, id)
	var i GetClientRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Secret,
		&i.TokenLivetime,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
select
    id,
    user_id,
    insert_date
from
    sessions
where
    id = $1
`

func (q *Queries) GetSession(ctx context.Context, id pgtype.Text) (Session, error) {
	row := q.db.QueryRow(ctx, getSession, id)
	var i Session
	err := row.Scan(&i.ID, &i.UserID, &i.InsertDate)
	return i, err
}

const getUser = `-- name: GetUser :one
select
    id,
    name,
    dot,
    password
from
    users
where
    id = $1
`

type GetUserRow struct {
	ID       string
	Name     string
	Dot      pgtype.Timestamp
	Password string
}

func (q *Queries) GetUser(ctx context.Context, id string) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Dot,
		&i.Password,
	)
	return i, err
}

const updateAuth = `-- name: UpdateAuth :exec
update auths
set
    use_date = now()
where
    code = $1
`

func (q *Queries) UpdateAuth(ctx context.Context, code pgtype.Text) error {
	_, err := q.db.Exec(ctx, updateAuth, code)
	return err
}

const updateSession = `-- name: UpdateSession :exec
update sessions
set
    user_id = $1
where
    id = $2
`

type UpdateSessionParams struct {
	UserID pgtype.Text
	ID     pgtype.Text
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.Exec(ctx, updateSession, arg.UserID, arg.ID)
	return err
}
